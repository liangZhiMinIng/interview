面试总结

###### 1.盒模型 (标准盒模型 / 怪异盒模型)

- 标准盒模型：标准盒模型标  box-sizing  :  content-box，标准盒模型设置宽度的值 是**内容区的宽度**，如果再设置 padding , border 的话，**盒子的实际宽度会增大**
- 怪异盒模型：怪异盒模型是  box-sizing  :  border-box，它的宽度为盒子的**实际宽度**，若再设置padding，margin，border的话，**盒子的实际大小不会改变。**
- 两者设置margin  都不会改变盒子的宽度。

###### 2.说说弹性布局

基础概念 + 父级容器属性 + 子级容器属性

- **基础概念**：采用flex布局，它所有子元素会自动成为flex容器成员。**flex弹性布局通过设置主轴和交叉轴的方式来控制子元素的排序方式，由父级容器和子级容器构成**。
- **父级容器的属性**：
  - **flex-direction**：定义了子元素排列方向
    - flex-direction: row | row-reverse | column | column-reverse;
  - **flex-wrap**:这个属性称为"轴线",`flex-wrap`属性定义，如果一条轴线排不下，如何换行。
  - flex-flow：是flext-direction 和 flex-wrap的简写形式。默认值为`row nowrap`。
  - justify-content：该属性定义了子元素在主轴上的**对齐方式**
    - `flex-start`（默认值）：左对齐
    - `flex-end`：右对齐
    - `center`： 居中
    - `space-between`：两端对齐，项目之间的间隔都相等。
    - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
  - align-items:定义在交叉轴上如何看齐
  - align-content:定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
- **子级容器**：
  - **order**属性:定义**子元素或者子容器**的**排列顺序**。**数值越小，排列越靠前，默认为0。**
  - **flex-grow**属性:定义**子元素的放大比例**，**默认为`0`**，即如果存在剩余空间，也不放大。如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
  - **flex-shrink**属性:**定义了子元素的缩小比例**，**默认为1**，即如果空间不足，该项目将缩小。如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。
  - **flex-basis**属性
  - **flex属性:**属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，**默认值为`0 1 auto`**。后两个属性可选。
    - **flex : 1  可以实现不同内容的div平分空间    flex : 1 === flex : 1 1 0 ;**
  - **align-self**属性:属性**允许单个**项目有**与其他**项目**不一样的对齐方式**

###### 3. Vue 的生命周期

- **beforeCreate:**
  - 在**实例初始化**之后，在**数据观测**(data observe)和**event**/watcher事件之前被调用，**在这个阶段data，methods，computed，watch上的数据和方法都不能被访问。**
- **created：**
  - **在实例完成之后被调用**
  - **在这个阶段没有 $el ，是不能与DOM进行交互的，如果想要和DOM进行交互，可以通过vm.$nextTick来访问DOM**
- -----------------------------------在这之前是 “ **实例** ” 相关的----------------------------------------------
- **beforeMount：**
  - **在开始挂载之前进行调用**
  - **相关的render函数首次被调用**
- **mounted:**
  - **在挂载完成后发生**
  - 在这个阶段，**1.  真实的dom挂载完毕**，**2.  数据完成双向绑定**，**3.  可以访问到DOM节点**
- ----------------------------------在这之前是于 "**挂载**" 相关的-----------------------------------------
- **beforeUpdate：**
  - 在数据**更新时**调用，发生在**1.   虚拟DOM重新渲染**和**2.  打补丁之前**
  - **可以在这个阶段进一步的更改状态**，不会触发**附加的重渲染过程**
- **updated：**
  - **发生在更新完成之后，在这个阶段   组件DOM   已经完成更新**
  - 这个钩子函数在服务器渲染期间不被调用
- ---------------------------------在这之前是于 "**更新**" 相关的------------------------------------------
- **beforeDestroy:**
  - 在实例销毁之前调用，在这一阶段，**实例仍然完全可用**
- **destroy：**
  - 在实例销毁之后调用，Vue实例指示的东西都会解绑，所有的事件监听器会被移除，左右的子**实例也会被销毁**，该钩子在服务器端渲染不被调用。
- ----------------------------------在这之前是于 “**销毁**” 相关的-----------------------------------------
- **activated**：
  - 组件被激活时调用
- **deactivated**：
  - 组件被销毁时调用
- -----------------------------------在这之前是于 “**组件**” 相关的----------------------------------------

###### 4.跨域怎么解决？

- 根据同源策略，只要是协议，域名，端口号不同就存在跨域问题。因此在js中的script标签里的src属性可以**跨域引用**js文件。JSONP发起GET请求后，后台会包装好一段json，把数据放在一个回调函数，返回一个js文件，动态引用这个js文件以后，会调用这个回调函数，通过这样访问数据。

- JSONP跨域

  - **jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签里的src属性来实现，JSONP发起GET请求后，后台会包装好一段json，把数据放在一个回调函数，返回一个js文件，通过src动态引用这个js文件以后，会调用这个回调函数，通过这样访问数据。
  - ![](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005093711895.png)
  - ![image-20211005093801633](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005093801633.png)
  - ![image-20211005093913857](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005093913857.png)

- 跨域资源共享(CORS)

  - CORS是一个W3C标准，全称是"跨域资源共享"。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，它需要浏览器和服务器的同时支持。
  - ![image-20211005094019635](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005094019635.png)

- nginx代理跨域

  - nginx配置解决iconfont跨域
    - 浏览器跨域访问 js ， CSS ，img ，等常规静态资源被同源策略允许，但iconfont字体文件是不被允许的，因此需要在nginx的静态资源服务器中配置以下操作。
    - ![image-20211005094559260](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005094559260.png)
  - nginx反向代理接口跨域

- nodejs中间件代理跨域

  - ```
    node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。
    ```

- ………………………………

###### 5. 浏览器缓存

**浏览器缓存**分为**http缓存**和**本地存储**

1. http缓存   分为  强缓存  和   协商缓存
   - 强缓存 ： 不发任何请求直接从浏览器中获取数据
     - 分为 ： expires  和   cache-control
   - 协商缓存 ： 发请求确认是否更新 ， 再决定是否返回 304 并从缓存中读取数据
2. 本地存储   分为  localStorage ,  sessionStorage  ,  cookie  , indexDB
   - localStorage  :  在前端设置，可以减少数据请求 ， 长期存储。
     - ![image-20211013090235504](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013090235504.png)
   - sessionStorage : 在前端设置，只存在当前会话中，重新打开浏览器则数据消失
     - ![image-20211013090533908](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013090533908.png)
   - cookie ： 在后端设置 ， 保存在客户端本地文件 ， 通过 set-cookie 设置 ，且cookie的内容自动在请求的时候被传递到服务器。
     - 创建一个cookie的对象：Cookie cookie = new Cookie("key","value")
     - 设置过期时间，通过 **setMaxAge** 方法来指定 cookie 的有效时间(以**秒**为单位) : **cookie . setMaxAge (60)**
     - ![image-20211013091353949](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013091353949.png)
     - 客户端保存cookie : **response . addCookie(cookie)** //**服务端将cookie发送给客户端。**
   - indexDB ： 是数据库缓存
   - ![image-20211005102658835](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005102658835.png)

###### 6. promise 和 async , await 的区别

首先都是处理异步请求的

1. promise的叙述：
   - promise 有三个状态  ： pending(执行中) ， success (成功) ,  reject (失败)
   - promise  语法： 
     - ![image-20211005104102288](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005104102288.png)
   - 错误捕获  catch
     - ![image-20211005104305152](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005104305152.png)
2. async   await  描述 ：
   - async  await  将异步强行转换为同步处理 ，
   - async 用于申明一个function是异步的 ， await 等待一个异步方法执行完成
     - ![image-20211005105352464](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005105352464.png)
   - 错误捕获，如果的reject状态，可以用 try-catch  捕捉
     - ![image-20211005105450302](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005105450302.png)
3. 区别
   1. promise 是ES6 的， async-await是ES7 的。
   2. async-await 相对于promise来讲，写法更加的优雅
   3. reject的状态：
      - promise的错误可以通过catch来捕捉，建议尾部捕获错误
      - async-await既可以用  .then 又可以用 try-catch 来捕捉

######  7. 深拷贝和浅拷贝

1. 解释 ： 假设 B 复制了 A ，当修改 A 时，看 B 是否会发生变化，如果 B 发生了变化，那么这就是浅拷贝，如果没变，就是深拷贝。

2. 实现浅拷贝的方法 ：
   - 用 for…in 只循环第一层
   - ![image-20211005111457280](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005111457280.png)
   - 用 Object.assign方法
   - ![image-20211005111539927](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005111539927.png)
   - 直接用 = 赋值
   - ![image-20211005111611445](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005111611445.png)
   
3. 深拷贝的方法：
   
   - 使用递归的方式实现深拷贝：
   - ![image-20211013094701360](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013094701360.png)
   - 
   
   - JSON.parse  ,  JSON.stringfiy
   - ![image-20211005111833469](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005111833469.png)

###### 8.  == 和 === 的区别

简单来说，== 是相等， ===   是严格相等。

当两个操作数用 ==  比较时，如果数据类型相同，则进行  ===(严格相等)  的比较 ； 若数据类型不同，则进行类型转换后再进行比较，而用  ===   进行比较时，若数据类型不同时，直接返回false。

###### 9.  Vue组件之间的传值

1. 父组件向子组件传递数据，采用的是  props  。
   - 在子组件中定义一个 props：{变量名：类型}
   - 在子组件中的template中用插值表达式引用这个变量
   - 在父组件中绑定  ：在props中定义的变量名=“变量名1”
   - 变量名1 在父组件中的data中定义
2. 子组件调用父组件的时候，采用的是 $emit 。
   - 在子组件的template处
     - ![image-20211005154126075](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005154126075.png)
     - ![image-20211005154212455](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005154212455.png)
   - 父组件的部分
     - ![image-20211005154325037](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005154325037.png)
     - ![image-20211005154420175](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005154420175.png)
3. eventBus 兄弟组件之间的数据传递,**如何传递？**
   1. 首先在  main.js  文件中创建一个新的  eventBus对象，然后给它导出。其实他是一个全新的 Vue实例。
      - export   const    eventBus  =   new   Vue()
      - **在导出时没有写  default  ,在引入时要加花括号。有default的话，就不用加**
   2. 然后在新创建的   BrotherCount    组件中导入   main.js
      - import   {eventBus}   from   "./main.js"
      - **现在我们可以使用  eventBus.$emit  来替代  this.$emit**
   3. 同样在   SisterCount  组件中导入  main.js
      - import   {eventBus}   from   "./main.js"
   4. 然后在   SisterCount  组件中  写入 created() 钩子函数，在这个钩子函数中可以增加一些自定义事件的侦听器。
4. 获取**单签组件的父组件**和**当前的子组件**：$parent 和 $childeren
5. A  -->  B --> C 使用 $attrs 和 $listeners
6. 父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量
7. $refs获取组件实例
8. vuex状态管理

###### 10.变量提升，函数提升

1. 函数提升只会提升函数声明，而不会提升函数表达式
   - ![image-20211005162356262](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005162356262.png)
2. **变量提升：指将变量声明的过程提升到她所在的作用域的顶端去执行，执行到代码所在的位置来赋值。**
   - ![image-20211005163948575](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005163948575.png)
   - ![image-20211005164019270](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211005164019270.png)

###### 11.  闭包是什么？

闭包是一个可以访问    **其他函数**    **内部变量**    **的函数**(通俗点讲就是函数a的内部函数b,被函数a外部的一个变量引用的时候, 就产生了一个闭包)

###### 12.判断数据类型的方法

1. **typeof**  :  
   - 可以判断出 number ,string ,boolean , undefined, object , symbol , function 
   - 但是用typeof来判断  **数组**  和 **对象**   时，都返回**object**。
   - 判断 **symbol** 和  **函数**  都返回  **function**
2. **instanceof** ：
   - instanceof  用来**判断 A 是否是 B 的实例** ，(A  instanceof  B), 若A 是 B 的实例，则返回true，否则返回false。
3. **constructor**  ：
   - [].constructor  ==   Array   =>  true
   - window.constructor  == window  true
4. **Object.prototype.toString()**  :
   - Object.prototype.toString({a:1})   =>  object  object

###### 13.  display : none ,， visibility : hidden , ，opacity : 0 之间的区别？

它们的共同点都是可以隐藏

1. 是否占据空间
   - display : none   隐藏后不占空间
   -  visibility : hidden  ，opacity : 0  隐藏后不占空间
2. 子元素是否继承
   - display : none   不会被子元素继承
   -  visibility : hidden  会被子元素继承 ，设置为 visible 来显示子元素
   - opacity : 0  会被子元素继承 
3. 事件绑定
   - display : none   无法触发所绑定的事件
   - visibility ：hidden  不会触发
   - opacity : 0  绑定的事件可以触发
4. 过度动画 transition
   - transition  对 display 和 visibility  是无效的
   - 对opacity是有效的

###### 14.  继承的方式

1.  **原型链继承** ： 让新实例的原型等于父类的实例
   - ![image-20211006203549167](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211006203549167.png)
2. **构造函数继承** ：可以用  . call ()  和 .apply () 将父类构造函数引入子类函数
3. **组合继承** (组合原型链继承和借用构造函数继承)  =>  常用
   - 可以继承父类原型上的属性，可以传参，可复用
4. 原型式继承  ： 类似于复制一个对象，用函数来包装
5. 寄生式继承
6. 寄生组合式继承

###### 15. 原型和原型链

1. 原型 ：

   - **原型只是函数的一个属性**

   - **原型是函数对象的属性，不是所有对象的属性**
   - **对象经过构造函数 new 出来，那么这个new出来的构造函数有一个属性叫原型。**

2. 原型链：

   - 核心就是对象的 _ proto _ 指向，当自身不存在某个属性时，就一层层的扒出创建对象的构造函数，直到看到object，就没有 _ proto _ 指向

###### 16. for……in ,，  for……of ，，for……each ，，set，，map的用法

1. **for……in** ：
   
   - 当遍历对象时，可以遍历出对象的属性
   - 当遍历数组时，可以遍历出数组的下标，且该下标是一个string对象
   
2. **for……of**：
   
   - 用来遍历数组的元素
   - 不可以直接遍历对象 ，需使用Object . keys() 来遍历对象的属性
   
3. **forEach** ：
   - 它接收一个函数作为参数，每次迭代就回调该函数
   - 用来遍历数组，但是不能使用  break  和  continue  来终止循环
   
4. **Set**:
- **set 类似于一个数组，且成员的值都是唯一的**
   - Set 具有的方法：
     - let set = new Set();
     - let arr = [1,2,3,4,5,4,5];
     - set . add (4)
     - set . delete (4) 
     - set . has(1)
     - set.clear() ;// 清楚所有成员，没有返回值
   - 用法：**可以对数组去重**
     - let set = new Set();
     - let arr = [1,2,3,4,4];
     - arr . forEach(**item => set . add(item)**);
     - console . log (set); //1 2 3 4
   - **数组快速去重**
     - let set = new Set();
     - let arr = [1,2,3,4,4,4];
     - console . log ([**...new Set(arr**)]);
   
5. **Array . from () 把类数组或集合转为数组，返回一个新的数组**。
6. **Map** :

   - map 对象是一个**键值对集合** 。
   - **map()方法返回一个新的数组，但是不会改变原数组。**
     - 语法： arr .  map(function(currentValue){}, thisValue);
   - 用Map来实现一组成绩单

     - **let score = new Map([ ['a',95] , ['b',78] , ['c',98] ]);**

     - **score . get ('a') //95**

     - Map 有以下几种方法：

       - let m = new Map() //空的Map

       - m . **set** ('d' ,67) ; //添加新的 key-value
       - m.  set ('b' ,88) ;//可以修改已有值
       - m . **has** ('a') ; //判断是否存在 a
       - m . **get** ('a' );
       - m.**delete** ('a')

###### 17.  call ,,  apply ,, bind 的区别

1. 相同之处：**可以改变函数体内 this 的指向**

2. 不同之处：

   - call ，apply 的区别是 ： 接收参数的方式不一样
   - bind ：是不立即执行 。而apply ，call是立即执行

3. bind  的使用

   - ```inform7
     语法：Function.bind(thisArg[, arg1[, arg2[, ...]]])
     ```

   - **bind 方法的返回值是函数，并且需要稍后调用，才会执行**。

4. call  和  apply  的区别

   - **调用 call的对象必须是函数** ， call 的第一个参数是一个对象 ，函数的调用者 ， 将会指向这个对象 。如果不传，则默认为全局对象window。**第二个参数开始，可以接收任意个参数**
   - 调用apply的对象也必须是函数function，接收两个参数，第一个参数是对象，**第二个参数必须是数组或者类数组**
     - 类数组：是一个具备与数组特征类似的对象
     - ![image-20211007211130186](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211007211130186.png)
     - **类数组无法使用  forEach , splice , push 等数组原型链上的方法。**
   - call  和 apply 的用途
     - call 的使用场景：
       - 对象的继承
       - ![image-20211007211637045](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211007211637045.png)
     - apply的使用场景：
       - **Math . max  用来获取数组中的最大一项**
         - let max = Math . max . apply (null ,array)
         - let min = Math . min .apply (null ,array)
       - **实现两个数组的合并**
         - let  arr1 = [1,2,3];
         - let  arr2 = [4,5,6];
         - **Array . prototype . push . apply (arr1,arr2)**
   - **call 和 apply 的使用例子**
     1. **合并两个数组**：Array . prototype . push . apply (数组名1，数组名2)
     2. **获取数组中的最大值和最小值**：
        - Math . max . apply (Math , arr)  ;
        - Math . max . call (Math , ...arr)

###### 18. 给数组添加元素可以用什么方法？数组的 API  有哪些？

1. **数组相关的属性和方法：**

   **array对象属性**：

   - length：返回数组的长度
   - **prototype**： **可以向对象添加属性和方法**

   **array对象方法：**

   - concat() : 连接两个或多个数组，并返回结果
   - **join()** : 用于把数组中的每个元素放入一个字符串，元素可以通过制定的分隔符分隔。
   - 
   - **pop()** : **删除并返回数组中的最后一个元素**
   - **push() : 向数组 的末尾添加一个或更多的元素，并返回新的长度**
   - 
   - **shift()** : **删除并返回数组中的第一个元素**
   - **unshift() : 向数组的开头添加一个或多个元素，并返回新的长度**
   - 
   - reverse() : 颠倒数组中元素的顺序
   - **slice()** : 从数组中**返回选定的元素** 
   - **sort() : 对数组中的元素进行排序**
   - **splice() : 删除元素，并向数组中添加新元素，该方法会改变原数组。**
   - toString() : 把数组转换为字符串，并返回结果

###### 19.  数组的 API 有哪些？

###### 20. es6 新增了哪些？

###### 21. H5 新增哪些？

###### 22.MVVM 和 MVM 区别？

###### 23.懒加载

1. 网页中图片多，加载的图片就多，那么服务器的压力就很大。为了提高用户体验，就出现了懒加载的方式来减轻服务器的压力。
2. **懒加载的原理**：浏览器发起是否请求图片是根据 img 标签的 src属性，所以实现懒加载的关键就是，在图片没有进入到可视区域使，先不给 src 属性赋值，这样浏览器就不会发送请求，等到图片进入到可视区域再给 src 进行赋值。

###### 24.css3 中弹性盒子怎么改变方向？  flex：direction

###### 25. 数组遍历的几种方法及用法？

1. **forEach** 方法 :提供一个回调函数，默认没有返回值。

   - ![image-20211013163924128](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013163924128.png)

2. **map** 方法 ： 返回一个新的数组，**不改变原数组**。

   - 语法： arr .  map(function(currentValue){}, thisValue);
   - ![image-20211013163846284](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013163846284.png)

3. **filter** 方法 ： **不改变原数组** , 原数组的元素执行了回调函数以后返回值为 **true** ，则将这个元素放入返回的数组中。

   - ![image-20211013163907786](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013163907786.png)

4.  **every**  ， **some**方法 ： **不改变原数组**

   1. every：
      - 当数组的每一个元素都执行这个回调函数，返回值全部为true ， every方法会返回true ；只要有一个返回false，则every方法返回false。
   2. some：
      - 当数组的每一个元素都执行这个回调函数，当有一个为true时，some方法返回true，当全部为false使，则some方法返回false。
   3. ![image-20211013171418071](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013171418071.png)

5. **reduce** 方法 ： 不改变原数组。reduce方法会让数组的每一个元素都执行一次这个回调函数，**并将上一次循环的返回值作为下一次循环的初始值**，最后将这个歌结果返回。

   - reduce方法有两个参数，第一个参数是一个回调函数（回调函数有四个参数），第二个参数是**初始值**
   - ![image-20211013172400473](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013172400473.png)

6. **for…of** 方法

   ![image-20211013172453242](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013172453242.png)

   

###### 26. vuex

1. vuex是专门为vue提供的全局状态管理系统，用于多个组件中数据共享，数据缓存等。
2. 主要包括以下几个模块：state , mutation , action , getter , module
3. vuex 页面刷新数据丢失怎么办？
   - 需要做vuex的数据持久化。

###### 27. css 选择器的优先级顺序

!important > 行内样式(div里的style写) > id选择器 > class选择器 > 标签选择器 > 通配符选择器

![image-20211013214350688](C:\Users\lzm\AppData\Roaming\Typora\typora-user-images\image-20211013214350688.png)

###### 28. bfc 块级格式化上下文

1. 块级格式化上下文，是一个独立的渲染区域，里面的元素不会影响到外面。
2. 形成 bfc 的条件
   - float 不可以为 none
   - display 可以是 flex ， inline-flex ， inline-block ，table-cell ，table-caption 
   - position ：可以是 fixed 或 absolute
   - overflow ：不可以是 visible

###### 29. 用js实现轮播图原理

**原理：通过改变图片的偏移量来实现图片的切换**

1.首先要有个盛放图片的容器，设置为单幅图片的宽高，且overflow：hidden，这样保证每次可以只显示一个图片
2、Container内有个放图片的list进行position的定位 ，其中的图片采用float的方式，同时当图片进行轮播时，改变list的Left值使得其显示的图片发生变化。

1. 通过 document . getElementById() 获取页面需要操作的元素

2. 实现左右箭头的切换 ：给左右箭头绑定点击事件

   - 每次切换时判断切换后的位置是否大于多少px或者小于多少px

3. 实现按钮点击切换 ：遍历按钮，给每个按钮添加点击事件

   button . onclick = function(){}

4. 实现图片自动切换 ：定义一个自动播放的定时器timer，每隔5s切换按钮

   timer = setInterval (function () {

   ​	next . onclick();

   },5000)

   //暂停自动播放

   function stop() {

   ​	clearInterval(timer)

   }

   //鼠标暂停在某张图片，则暂停切换

   banner . onmouseover = stop ;

   //鼠标移除时，继续自动切换

   banner . onmouseout = play ;

###### 30.link标签和import标签的区别

- link 标签是 HTML标签，而 @import 是css提供的
- 页面被加载时，link 标签会被同时加载，而 @import 会等到页面加载结束后加载
- 以link方式引入的样式的权重高于@import的。

###### 31. transition 和 animation 的区别

- transition 需要触发一个事件才能改变属性，而 animation 不需要触发任何事件的情况下才会随时间改变属性值。
- transition 是 2 帧 ，从 from……to ，animation是可以一帧一帧的

###### 32. 块元素 和 行元素

- 块元素可以独占一行，可以设置 padding 和 margin 以及高度和宽度
- 行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。

###### 33.多行文本省略号

display : -webkit-box

-webkit-box-orient : vertical

-webkit-line-clamp:3

overflow:hidden

###### 34.position 属性的比较

- fixed : 固定定位
  - 元素的位置相对于浏览器是固定定位，fixed定位使元素的位置与文档流无关，因此不占空间。
- relative ：相对定位
  - 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。
- absolute ：绝对定位
  - 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。
- sticky ：粘性定位
- static ：默认定位
  - 默认值。没有定位，元素出现在正常的流中

###### 35.重绘，重排。怎么减少重绘和重排？

1. 重绘不一定会重排，重排必然会导致重绘
2. 引起重排，重绘的原因是什么？
   - 添加或者删除可见的DOM元素
   - 元素尺寸位置的改变
   - 浏览器页面初始化
   - 浏览器窗口大小发生改变
3. 减少重排重绘的方法：
   - 不在布局信息改变时做DOM查询
   - 使用csstext ， className 一次性改变属性
   - 使用fragment

###### 36. get 请求  传参长度的误区

- http协议从没有规定get/post的请求长度限制是多少。
- 对 get 请求参数的限制是来源浏览器和 web服务器
- get显示的最大长度是因为浏览器和web服务器**限制了URL的长度**

###### 37.get 和 post 请求在缓存方面的区别

1. get请求来获取数据时，可以不用每次都与数据库连接，它是可以使用缓存的
2. post请求数据是必须要与数据库进行交互的，所以不能使用缓存。

###### 38. 搜索框实现模糊查询方法

1. 对数组通过filter的方式进行遍历，查询搜索的key
2. 对遍历出的结果进行字符串的模糊查询 str . indexOf("xxx") != -1











